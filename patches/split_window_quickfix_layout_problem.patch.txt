Fixes this bug:

    Splitting quickfix window messes up window layout. (Marius Gedminas, 2007
    Apr 25)

The bug was also reported by Ming Bai and mbbill on the Vim users maillist,
July 24, 2007.  Thanks for the detailed descriptions!

How to trigger the bug:

    1) Create a new directory, change to it, create aa.txt and bb.txt:
       Content of aa.txt: "aabbcc"
       Content of bb.txt: "aacccc"
    2) Run Vim.
    3) :set buftype=nowrite
    4) :vsplit
    5) :silent vim aa *
    6) Type <ctrl-o>.
    7) :copen
    8) Type j and <enter>  (in the Quickfix window, choose bb.txt and open it).
    9) :q
       The Quickfix window is now overlapping the other window in the column.

The problem is caused by a too simplistic solution for handling the
distribution of free height (and width, though it is not shown by the example)
from a closed frame to another frame, whose window has 'winfixheight' (or
'winfixwidth') set.  This patch brings in a smarter solution, which tries to
distribute free height/width to the frame of a non-fixed-height/width window in
the column/row as close to the closed frame as possible.  If none is found, the
original frame has to get the height/width, even though its window has
'winfixheight' or 'winfixwidth' set.

Created by Martin Toft Bay <mt@martintoft.dk> during Google Summer of Code 2007.


Index: src/quickfix.c
===================================================================
RCS file: /cvsroot/vim/vim7/src/quickfix.c,v
retrieving revision 1.66
diff -c -r1.66 quickfix.c
*** src/quickfix.c	28 Jun 2007 19:33:20 -0000	1.66
--- src/quickfix.c	2 Aug 2007 16:56:26 -0000
***************
*** 1612,1619 ****
  	}
  
  	/*
! 	 * If there is only one window and is the quickfix window, create a new
! 	 * one above the quickfix window.
  	 */
  	if (((firstwin == lastwin) && bt_quickfix(curbuf)) || !usable_win)
  	{
--- 1612,1619 ----
  	}
  
  	/*
! 	 * If there is only one window and it is the quickfix window, create a
! 	 * new one above the quickfix window.
  	 */
  	if (((firstwin == lastwin) && bt_quickfix(curbuf)) || !usable_win)
  	{


Index: src/window.c
===================================================================
RCS file: /cvsroot/vim/vim7/src/window.c,v
retrieving revision 1.62
diff -c -r1.62 window.c
*** src/window.c	26 Jul 2007 20:56:50 -0000	1.62
--- src/window.c	2 Aug 2007 16:56:29 -0000
***************
*** 2121,2127 ****
  	if (wp->w_p_pvw || bt_quickfix(wp->w_buffer))
  	{
  	    /*
! 	     * The cursor goes to the preview or the quickfix window, try
  	     * finding another window to go to.
  	     */
  	    for (;;)
--- 2121,2127 ----
  	if (wp->w_p_pvw || bt_quickfix(wp->w_buffer))
  	{
  	    /*
! 	     * If the cursor goes to the preview or the quickfix window, try
  	     * finding another window to go to.
  	     */
  	    for (;;)
***************
*** 2329,2361 ****
      if (frp_close->fr_parent->fr_layout == FR_COL)
      {
  #endif
! 	/* When 'winfixheight' is set, remember its old size and restore
! 	 * it later (it's a simplistic solution...).  Don't do this if the
! 	 * window will occupy the full height of the screen. */
! 	if (frp2->fr_win != NULL
! 		&& (frp2->fr_next != NULL || frp2->fr_prev != NULL)
! 		&& frp2->fr_win->w_p_wfh)
! 	    old_size = frp2->fr_win->w_height;
  	frame_new_height(frp2, frp2->fr_height + frp_close->fr_height,
  			    frp2 == frp_close->fr_next ? TRUE : FALSE, FALSE);
- 	if (old_size != 0)
- 	    win_setheight_win(old_size, frp2->fr_win);
  #ifdef FEAT_VERTSPLIT
  	*dirp = 'v';
      }
      else
      {
! 	/* When 'winfixwidth' is set, remember its old size and restore
! 	 * it later (it's a simplistic solution...).  Don't do this if the
! 	 * window will occupy the full width of the screen. */
! 	if (frp2->fr_win != NULL
! 		&& (frp2->fr_next != NULL || frp2->fr_prev != NULL)
! 		&& frp2->fr_win->w_p_wfw)
! 	    old_size = frp2->fr_win->w_width;
  	frame_new_width(frp2, frp2->fr_width + frp_close->fr_width,
  			    frp2 == frp_close->fr_next ? TRUE : FALSE, FALSE);
- 	if (old_size != 0)
- 	    win_setwidth_win(old_size, frp2->fr_win);
  	*dirp = 'h';
      }
  #endif
--- 2329,2405 ----
      if (frp_close->fr_parent->fr_layout == FR_COL)
      {
  #endif
! 	/* When 'winfixheight' is set, try to find another frame in the column
! 	 * (as close to the closed frame as possible) to distribute the height
! 	 * to. */
! 	if (frp2->fr_win != NULL && frp2->fr_win->w_p_wfh)
! 	{
! 	    frp = frp_close->fr_prev;
! 	    frp3 = frp_close->fr_next;
! 	    while (frp != NULL || frp3 != NULL)
! 	    {
! 		if (frp != NULL)
! 		{
! 		    if (frp->fr_win != NULL && !frp->fr_win->w_p_wfh)
! 		    {
! 			frp2 = frp;
! 			wp = frp->fr_win;
! 			break;
! 		    }
! 		    frp = frp->fr_prev;
! 		}
! 		if (frp3 != NULL)
! 		{
! 		    if (frp3->fr_win != NULL && !frp3->fr_win->w_p_wfh)
! 		    {
! 			frp2 = frp3;
! 			wp = frp3->fr_win;
! 			break;
! 		    }
! 		    frp3 = frp3->fr_next;
! 		}
! 	    }
! 	}
  	frame_new_height(frp2, frp2->fr_height + frp_close->fr_height,
  			    frp2 == frp_close->fr_next ? TRUE : FALSE, FALSE);
  #ifdef FEAT_VERTSPLIT
  	*dirp = 'v';
      }
      else
      {
! 	/* When 'winfixwidth' is set, try to find another frame in the column
! 	 * (as close to the closed frame as possible) to distribute the width
! 	 * to. */
! 	if (frp2->fr_win != NULL && frp2->fr_win->w_p_wfw)
! 	{
! 	    frp = frp_close->fr_prev;
! 	    frp3 = frp_close->fr_next;
! 	    while (frp != NULL || frp3 != NULL)
! 	    {
! 		if (frp != NULL)
! 		{
! 		    if (frp->fr_win != NULL && !frp->fr_win->w_p_wfw)
! 		    {
! 			frp2 = frp;
! 			wp = frp->fr_win;
! 			break;
! 		    }
! 		    frp = frp->fr_prev;
! 		}
! 		if (frp3 != NULL)
! 		{
! 		    if (frp3->fr_win != NULL && !frp3->fr_win->w_p_wfw)
! 		    {
! 			frp2 = frp3;
! 			wp = frp3->fr_win;
! 			break;
! 		    }
! 		    frp3 = frp3->fr_next;
! 		}
! 	    }
! 	}
  	frame_new_width(frp2, frp2->fr_width + frp_close->fr_width,
  			    frp2 == frp_close->fr_next ? TRUE : FALSE, FALSE);
  	*dirp = 'h';
      }
  #endif
